
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[a4paper]{llncs}

\usepackage[spanish,activeacute]{babel}
\usepackage[latin1]{inputenc}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage[Algoritmo]{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{amsmath}
\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{NodIO: Marco de desarrollo de aplicaciones para computación evolutiva voluntaria}

% a short form should be given in case it is too long for the running head
\titlerunning{NodIO: Marco de desarrollo orientado a computación evolutiva }

% the name(s) of the author(s) follow(s) next
%
\author{Israel Blancas, J. J. Merelo \and Antonio Álvarez}
%
% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published

\institute{Departamento de Arquitectura y Tecnología de Computadores,
Universidad de Granada, España}

\maketitle

\begin{abstract}
La computación voluntaria es un tipo de computación distribuida que permite
realizar experimentos utilizando la potencia de cálculo proporcionada
por las máquinas de usuarios que deciden colaborar libremente en la investigación.
\texttt{NodIO} \cite{nodio} es un marco de desarrollo de aplicaciones para la creación de este
tipo de experimentos. A diferencia de otros marcos de desarrollo que realizan las mismas
tareas, \texttt{NodIO} no necesita instalar ninguna aplicación ni biblioteca en
el lado del cliente, ya que se
encuentra escrito en JavaScript, por lo que solo será necesario
tener un navegador web o un intérprete.
%%%
En este trabajo se detallará el funcionamiento de \texttt{NodIO},
además de mostrar dos experimentos para demostrar los beneficios
que exponemos: sencillez y rendimiento.

Ambos experimentos nos demostrarán cómo, al aumentar
el número de ``voluntarios'', el tiempo en alcanzar una solución
desciende.

\end{abstract}


\begin{keywords}
  Computación voluntaria,  algoritmos evolutivos, computación distribuida,
  computación en la nube, evaluación de rendimiento
\end{keywords}

\section{Introducción}

Diversos son los métodos utilizados para el procesamiento de grandes
conjuntos de resultados obtenidos
a través de la elaboración de experimentos o, en su defecto, la propia
realización de los experimentos; entre ellos está el uso de un único supercomputador para
todo el procesamiento, la creación de un clúster de máquinas en un centro
de procesamiento (o \textit{cloud}) o el uso de un grid o de recursos
en la nube. Sin embargo, por cuestiones presupuestarias, algunas veces
la única opción viable es recurrir a la computación voluntaria.
Este es un modelo de computación distribuida basado en la colaboración
independiente de usuarios de cualquier condición académica utilizando sus recursos, generalmente ociosos.
Esta colaboración se produce entre computadores independientes, interconectados
a través de una o varias redes, para comunicar y coordinar sus tareas contruyendo
redes con potencia equivalente (o incluso superior) a la de supercomputadores.

Nuestro objetivo es trabajar con algoritmos evolutivos de manera eficiente,
ya que son costosos en tiempo de cómputo. Este tipo de algoritmos se basan en
el modelo evolutivo de Darwin. Se comienza con una población de individuos,
la cual sometemos a un modelo simulado de selección natural: selección, cruce,
mutación y reemplazo. El principal problema de eficiencia de estos algoritmos es el elevado
número de operaciones que hay que realizar para cada individuo de la población. Aunque, por otro lado,
con un buen diseño de este tipo de algoritmos se consigue
un equilibro entre exploración y explotación de un espacio de soluciones, por lo que
en general este tipo de algoritmos dan buenas soluciones a problemas con grandes espacios
de búsqueda.

La computación voluntaria es un método de cómputo mediante el cual se
permite a distintos usuarios colaborar en un proyecto científico,
en muchas ocasiones, aprovechando el tiempo ocioso de sus máquinas. Esta colaboración
se produce entre computadores independientes, interconectados a través de una o varias redes
para comunicar información y coordinar sus tareas construyendo redes con potencias
equivalentes a la de los supercomputadores o, incluso, superiores.


En este artículo se mostrará un marco para trabajar con computación
voluntaria en algoritmos evolutivos, \texttt{NodIO}, así como las mejoras de tiempo producidas
al utilizar este modelo. \texttt{NodIO} es un marco de desarrollo de experimentos
de computación evolutiva en nube, que frente a los marcos actuales,
no precisa de instalación de ningún software por parte del usuario voluntario, salvo un navegador
web.


Como queda descrito en publicaciones como \cite{durrani2014volunteer}, \cite{nodio} y \cite{sarmenta1998bayaniha},
en estos sistemas se desean características como tolerancia a fallos (es conveniente que la
pérdida de datos sea mínima), ejecución en múltiples
máquinas (para obtener la potencia de cálculo necesaria),
compatibilidad entre los dispositivos conectados (la información intercambianda debe entenderse por
todos los dispositivos del sistema),
seguro (evitando que haya usuarios malintencionados que traten de realizar algún tipo de actividad
nociva para el resto) y, por último, escalabilidad.

La capacidad de cómputo del sistema variará en función del número de
usuarios que decidan colaborar, la potencia de sus dispositivos
y de la capacidad del servidor para repartir y recoger resultados.

Además, gracias a que son los usuarios quienes ``prestan" sus máquinas, el sistema
es más barato que la contratación de cómputo o la compra de material
dedicado. Si además tienen la oportunidad de utilizar algún tipo de infraestructura
gratuita como pueden ser muchos ``Plataforma como servicio'', el coste es menor aún.

Por su contra, la dificultad para llegar a un número importante de gente y los posibles
problemas que pueden aparecer en cuanto a la fiabilidad o corrección de los datos
(aunque se pueden establecer mecanismos como la computación redundante
para asegurar la corrección o la firma de código para prevenir modificaciones maliciosas
del \textit{software}), hacen que el método no sea ideal.

En estos sistemas, los usuarios depositan su confianza en el proyecto, suponiendo que el \textit{software}
que están ejecutando no daña sus dispositivos, el cómputo que se está realizando
servirá para cubrir la necesidad que se ha anunciado y que el sistema está blindado para
que ningún usuario malintencionado lleve a cabo ningún tipo de actividad ilícita.


El resto del trabajo se organiza de la forma siguiente: la Sección \ref{sec:arte}
dará al lector encontrará algunos ejemplos de sistemas de computación voluntaria,
además de algunos marcos de desarrollo de aplicaciones de este estilo. La siguiente
Sección, la \ref{sec:nodio}, detalla el funcionamiento y arquitectura que compone
a \texttt{NodIO}, comentando el algoritmo que se sigue y el intercambio de mensajes
entre clientes y servidor. En la Sección \ref{sec:experimentos} se mencionan los experimentos
realizados en anteriores publicaciones y la información que aportaron.
Además, se detallará cómo se han realizado otros dos nuevos,
que harán claro para el lector las ventajas de la computación voluntaria (en especial las
del marco \texttt{NodIO}). Finalmente,en la Sección \ref{sec:conclusiones} se recojen
las conclusiones extraídas tras los experimentos y se proponen algunos trabajos futuros para,
principalmente, fomentar la participación de nuevos voluntarios.


\section{Estado del arte}
\label{sec:arte}
Muchos son los proyectos que utilizan computación voluntaria
para realizar sus cálculos. El primero de ellos fue ``Great Internet Mersenne Primer Search'' \cite{gimps},
en el año 1996, un sistema para calcular primos de Mersenne. Aunque el código de fuente es de dominio
público, no se considera \textit{software} libre ya que los usuarios deben aceptar unas condiciones sobre la propiedad
intelectual de los resultados obtenidos, por lo que más tarde nacieron algunas versiones que lo son totalmente.

\texttt{IBM} cuenta con un programa de computación voluntaria con el que trata de alcanzar soluciones
a enfermedades como el cáncer \cite{ibmwcg} y que cuenta con miles de voluntarios.

Especialmente conocido es el proyecto \texttt{SETI@home}, descrito en \cite{seti}, el cual funciona en la
plataforma informática  \textit{``Berkeley Open Infrastructure for Network Computing''} \cite{ries2012berkeley}. Este
sistema analiza señales de radio buscando vida extraterrestre. Dentro de la misma plataforma, podemos encontrar
otros muchos proyectos, como \textit{``Climate Prediction''} \cite{climate} mediante el cual se trata
de predecir el clima. Esta plataforma es libre y permite crear proyectos propios aunque tiene un gran
problema: para que los usuarios participen, es necesario que instalen un \textit{software}
que se encargará de aprovechar el procesador de los voluntarios en aquellos momentos en los que no estén haciendo nada).

Existen algunos otros desarrollos como el que encontramos en \cite{sarmenta1998bayaniha} o \cite{jadif}.
Estos dos marcos de desarrollo nos permiten crear nuestros experimentos de computación voluntaria utilizando el lenguaje
de programación \texttt{Java}. Al igual que en los casos anteriores, necesitaremos que los voluntarios descarguen e instalen
un programa (además de las propias dependencias de \texttt{Java}), lo que puede provocar que muchos usuarios no se sientan
atraídos a colaborar.

En cuanto a marcos de desarrollo orientados a computación voluntaria con algoritmos evolutivos, ya en \cite{cole2010evolutionary}
podemos ver un análisis de algunas plataformas y comparaciones de rendimiento entre ellas. Sin embargo, \texttt{NodIO} añade
va más allá: permite ejecutar el cómputo desde el navegador al estar escrito el cliente en \texttt{JavaScript}. Esto facilita
la participación en el experimento ya que cualquier dispositivo que sea capaz de ejecutar un navegador web va a poder
ejecutarlo. Deriva de aquí otra ventaja: al solo necesitarse un navegador web, no es necesario que el usuario
se preocupe de instalar ningún software adicional en su máquina.


\section{NodIO, un marco para algoritmos evolutivos distribuidos}
\label{sec:nodio}
Los algoritmos evolutivos \cite{hispalinux2002,araujo2009algoritmos}
son métodos bioinspirados de búsqueda y optimización que trabajan
sobre una población de posibles soluciones, haciéndolas evolucionar
según un método basado en la selección natural: mutación o cambio
aleatorio, {\em crossover} o generación de nuevas soluciones
combinando existentes, y selección aleatoria de las mejores soluciones
de acuerdo con una función de {\em fitness} o adecuación
establecida. A lo largo de una serie de generaciones, un algoritmo
genético va creando, en media, mejores soluciones hasta que se alcanza
el nivel deseado de {\em fitness} o la solución, si existe.

La paralelización de un algoritmo evolutivo es una operación
relativamente simple \cite{maeb03:maribel}: simplemente distribuyendo
la población entre diferentes nodos computacionales que intercambien,
cada cierto intervalo de tiempo, individuos, se puede conseguir un
sistema distribuido con un buen escalado y unas prestaciones
aceptables. Por eso se han desarrollado e implementado diferentes
sitemas de tal tipo, incluso basados en web \cite{LNCS2439:ID197:pp665,maeb2007:dcor} y
destinados a computación voluntaria.

\texttt{NodIO} \cite{nodio}, como se ha mencionado, es un marco de desarrollo crear experimentos de
computación voluntaria utilizando algoritmos evolutivos. En este caso, está pensado para ser desplegado en un
``Plataforma como Servicio''. Para el desarrollo de
los algoritmos se basa en un marco de desarrollo llamado \texttt{NodEO} \cite{nodeo},
desarrollado en \texttt{NodeJS}.

Gracias a esta implementación del lado cliente, se pueden lanzar experimentos y que los voluntarios los ejecuten
a través de un navegador (o cualquier sistema que ejecute el lenguaje \texttt{JavaScript}
y que disponga de conexión a Internet).

\texttt{NodIO} funciona según un paradigma cliente-servidor. El servidor realiza la coordinación de los clientes,
almacena los distintos cromosomas y el estado de los experimentos y reinicia el experimento
cuando se ha encontrado la solución. El acceso y envío de los distintos cromosomas se hace a través de
una interfaz \texttt{API/REST}. Las peticiones -que siguen el ciclo ``\texttt{CRUD}''- utilizan el formato \texttt{JSON}. El cliente es
quien procede con el cómputo y, para obtener y enviar datos, hace peticiones asíncronas al servidor utilizando
la antes mencionada \texttt{API/REST}. En aquellos navegadores en los que esté permitido, se ejecuta utilizando ``\texttt{Web Workers}''
(en caso contrario, se ejecuta una versión preparada para ello).

Teniendo clara esta separación, es hora de ver el papel que juegan cada uno de los elementos
dentro del algoritmo \ref{algoritmo}.

Para que al lector le sea más sencillo comprender el algoritmo y el paso de mensajes que
se produce entre cliente y servidor, puede ver la figura \ref{visual}.

Para la creación de un nuevo experimento necesitaremos modificar, al
menos, dos ficheros: ``\texttt{is\_solution.js}'',
que se ejecuta en el servidor y decide si el cromosoma enviado por el
cliente es una solución aceptable, y
``\texttt{trap.standalone.js}'', que se ejecuta en el cliente y es la que
incluye la función de \textit{fitness} a optimizar y el resto del algoritmo
evolutivo. Dependiendo de
las necesidades que tenga el experimento deseado, especialmente de
otros operadores genéticos o facilidades en el servidor habrá que revisar
otros archivos para ajustar aquellos parámetros que se deseen; como
\texttt{NodIO} cuenta con una licencia libre,
esto no es problema.

\begin{algorithm}[H]
  \caption{Algoritmo utilizado en NodIO para la realización de experimentos}
  \label{algoritmo}
  \begin{algorithmic}
    \State Inicio del $servidor$
    \State $numero\_secuencia \gets 0$
    \State $poblacion\_compartida \gets random[]$
    \State Se crea el archivo de log
    \ForAll{$clientes$}
       \State $cliente$ accede al link
       \State $servidor$ envía la página y los scripts a ejecutar
       \State $cliente$ renderiza la página
       \Loop
         \State $UUID \gets new\_UUID$
         \State $poblacion \gets generarPoblacionInicial()$
         \Repeat
            \While{$poblaciones\_generadas\leq n$}
               \State $poblacion \gets generarPoblacion(poblacion)$
            \EndWhile
            \State El $cromosoma$ con mejor $fitness$ es enviado al $servidor$
            \If{$Not\ mejor\_global(cromosoma)$}
                \State $servidor$ envía un $cromosoma$ aleatorio de $poblacion\_compartida$
                \State $servidor$ envía el número actual de generación y el mejor $cromosoma$
                \State $cliente$ actualiza los gráficos
            \EndIf
         \Until{mejor-global(cromosoma)}
         \State $cliente$ actualiza los gráficos
         \State El experimento acaba
         \State El $numero\_secuencia \gets numero\_secuencia+1$
         \State $poblacion\_compartida \gets random[]$
         \EndLoop
      \EndFor

  \end{algorithmic}
\end{algorithm}

\begin{figure}[h]
\includegraphics[scale=0.65]{img/algoritmo}
\caption{Algoritmo \ref{algoritmo} explicado de forma visual}
\centering
\label{visual}
\end{figure}

\section{Experimentos}
\label{sec:experimentos}
Algunos experimentos ya fueron hechos en \cite{nodio} para mostrar la velocidad de ejecución de los distintos
cómputos en \textit {JavaScript} frente a otros lenguajes. En este trabajo se ha procedido a realizar algunos experimentos
para mostrar, a pequeña escala, el beneficio que nos aporta la
computación voluntaria en cuanto a rendimiento. Mientras anteriormente se comparaba el mismo algoritmo
escrito en distintos lenguajes siendo ejecutados por una sola máquina, ahora se procede a comprobar cómo
influye en la rapidez para alcanzar una
solución ejecutar los algoritmos escritos en \texttt{Javascript} en más de una máquina.

En un primer experimento, se ha comprobado el tiempo de ejecución en
función del número de pestañas
que están ejecutando el cliente. La máquina que hace de servidor hace
también las veces de cliente,
comenzando la ejecución de los clientes de forma síncrona. Como problema a resolver,
se ha utilizado el de resolver la función ``\texttt{trap}'', con los valores descritos en la
tabla \ref{var-table}.

Se han escogido estos valores
para conseguir un experimento que sea relativamente sencillo, de forma que se pudiera medir
fácilmente el tiempo que tarda en resolverlo un solo voluntario. Estas pruebas se han hecho en un
sistema operativo \texttt{GNU/Linux} (distribución \texttt{ArchLinux} con \texttt{kernel} 4.5.1) con un procesador \texttt{i5-2410M CPU @
  2.30GHz}. El navegador utilizado ha sido la versión 50 de \texttt{Chromium}, un navegador libre que usa el mismo motor que Chrome de Google.

En el experimento se han ido variando el número de pestañas abiertas y se ha ejecutado el experimento
varias veces (calculando una media ponderada para representar la gráfica de la figura \ref{tiempo-pestanas}).
Como podemos observar, cuando solo tenemos una pestaña abierta, el tiempo se
dispara (en torno a unos 3 minutos). En el caso de dos pestañas, el tiempo descendió hasta
un tiempo estimado de 53.22 segundos. En el resto de los casos, aunque sigue habiendo
diferencias de tiempo (unos 14.56, 10.11 y 7.46 segundos respectivamente), no es
tan notable como en los otros dos casos. Esto puede tener varias explicaciones: por un
lado al aumentar el número de pestañas, el poder computacional desciende (el
sistema operativo se ve con una carga de trabajo con la que tiene que lidiar).
Por otro, llegará un momento en el que no se podrá reducir más el tiempo
de ejecución por la propia naturaleza del problema.


Para el segundo experimento, se ha medido el tiempo que tarda en
alcanzarse una solución
utilizando como clientes hasta tres dispositivos con la misma
configuración hardware -teléfonos
móviles \texttt{LG Bello II} con procesador \texttt{quad-core Cortex-A7 1.3GHz} con
\texttt{Android} versión 5.0.2 y navegador \texttt{Chrome}-.
También se han ejecutado de forma síncrona en los tres teléfonos.

En la figura \ref{tiempo-dispositivos} podemos ver los resultados.  Si comparamos con
la figura \ref{tiempo-pestanas}, es sencillo ver que existe simetría, aunque
en este nuevo caso los tiempos son algo mayores (que podemos achacar a un menor rendimiento
por parte del procesador del dispositivo móvil y a la existencia de una red entre
el servidor y los dispositivos, cuando antes se ejecutaba todo dentro de la misma
máquina).

\begin{table}[hbpt]
\label{var-table}
\begin{tabular}{|l|l|}
\hline
\textbf{Variable}      & \textbf{Valor} \\ \hline
Número de traps        & 24             \\ \hline
Longitud del trap      & 4              \\ \hline
b                      & 2              \\ \hline
a&1\\ \hline
Caché                  & 32             \\ \hline
Tamaño de la población & 128            \\ \hline
\end{tabular}
\centering
\caption{Valores de las variables utilizados para el experimento}
\end{table}

\begin{figure}[htbp]
\includegraphics[scale=0.65]{img/tiempo-pestanas}
\centering
\caption{Resultados obtenidos al medir el tiempo que se tarda en alcanzar la
solución en un mismo ordenador en función del número de pestañas abierto}
\label{tiempo-pestanas}
\end{figure}

\begin{figure}[htbp]
\includegraphics[scale=0.65]{img/tiempo-dispositivos}
\centering
\caption{Resultados obtenidos al medir el tiempo que se tarda en alcanzar una
solución utilizando varios dispositivos con la misma configuración hardware y software}
\label{tiempo-dispositivos}
\end{figure}



\section{Conclusiones y trabajo futuro}
\label{sec:conclusiones}
Mediante los experimentos que se realizaron en \cite{nodio}, el lector
ha podido comprobar que
\texttt{JavaScript} es un lenguaje suficientemente rápido como para realizar
este tipo de experimentos, y en todo caso es la única opción para que
los voluntarios participen en experimentos distribuidos usando el
navegador.
En este artículo, a través de los experimentos realizados en la sección previa, podemos comprobar
a muy pequeña escala, los beneficios de la computación voluntaria en lo que a mejora de prestaciones
se refiere. Hay que recordar que este tipo de sistemas se encuentran diseñados para
ser utilizados por una gran cantidad de clientes y que esto es solo un experimento en un
entorno controlado. El primer experimento, aunque la utilización de la misma máquina
como servidor y cliente hace que no se pueda mostrar toda la potencia que tiene el sistema, nos
permite ya ver una gran mejora. En el caso del segundo, vemos como, aunque utilicemos dispositivos
que no tienen tanta potencia de procesamiento como un computador convencional, también tienen un
gran poder de cómputo, reduciendo notablemente el tiempo en alcanzar una solución conforme
aumenta el número de dispositivos.

En cuanto a trabajos futuros, muchas son las ideas que se pueden desarrollar utilizando esta
herramienta (o a partir de la misma). La idea más directa de todas es la realización de nuevos
experimentos, no tanto sobre la velocidad para alcanzar la solución a un problema dado como
para investigar sobre el comportamiento de los usuarios, es decir, una vez lanzado un experimento
tratar de conocer si los usuarios se sienten atraídos por la idea de participar en un
experimento -difundiendo un enlace al mismo a través de redes sociales- y, una vez que han iniciado
el experimento, cuánto tiempo participan. Dentro de esta línea, la idea de incluir técnicas
relacionadas con ``ludificación'' (para atraer a los usuarios y hacer que estos se queden más tiempo
ejecutando los distintos experimentos) sería otra cuestión a resolver, junto con la internacionalización
de la aplicación, que, al aumentar el número de idiomas, permitirá llegar a más
voluntarios. Conseguir una mayor automatización en la creación
de los experimentos es un camino a tener en cuenta, facilitando que cualquiera pueda implementar
de forma más secilla nuevos experimentos lo que necesite.

\section{Reconocimientos}

Reconocemos el apoyo del proyecto del Ministero español de Economía y Competitividad TIN2014-56494-C4-3-P,
el Ministerio español de Educación, Cultura y Deporte por la ``Beca de Colaboración'' concedida en el año 2015
y de la Universidad de Granada por la ``Beca de Iniciación a la Investigación"  del Plan Propio concedida en
el 2015.


\bibliographystyle{splncs}
\bibliography{volunteer}
\nocite{*}

\end{document}
